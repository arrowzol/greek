#!/usr/local/bin/python3

import go_greek as g
import sys

DO_DECLS = "123"
DO_DECLS = "3"
DO_DECLS = "12"

_show_errr_dbg = "-GEW"

def_art_base = (
# singular --------------
#   mas     fem     neu
    "ο",    "η",    "το",       # nominative
    "του",  "της",  "του",      # genative
    "τω",   "τη",   "τω",       # dative
    "τον",  "την",  "το",       # accusative
# plural ----------------
#   mas     fem     neu
    "οι",   "αι",   "τα",       # nominative
    "των",  "των",  "των",      # genative
    "τοις", "ταις", "τοις",     # dative
    "τους", "τας",  "τα")       # accusative

def_art_to_indexes = {}
for def_art, index in zip(def_art_base, range(2*3*4)):
    if not def_art in def_art_to_indexes:
        def_art_to_indexes[def_art] = []
    def_art_to_indexes[def_art].append(index)


def wgt(where):
    if where == "SN":
        return 10
    return 1

def str_rm(s, i):
    if i == 0:
        return s
    return s[:-i]

def read_words(files, show_ch_vs=False):
    """
    Read greek words from a list of files
    """
    for fn in files:
        fh = open(fn)

        ch = '0'
        for line in fh:
            if line.startswith("CH "):
                ch = line[3:].rstrip()
                continue

            tail = 0;
            in_num = False
            for head in range(len(line)):
                let = line[head]
                if let >= "0" and let <= "9":
                    if not in_num:
                        if head > tail:
                            yield line[tail:head]
                        tail = head
                        in_num = True
                    continue

                if in_num:
                    in_num = False
                    if show_ch_vs:
                        yield ch + ":" + line[tail:head]
                    tail = head

                if not let in g._all_greek_letter_set:
                    if head > tail:
                        yield line[tail:head]
                    if let != " ":
                        yield let
                    tail = head+1
            if tail > head:
                yield line[tail:]
            yield "EOL"
        fh.close()

_3_mf = [g._noun_stems["3"]["-"][num][cas]
    for num in "SP"
    for cas in "NGDA"
    ]

# look out for NS and DP, their endings start with a consonant and many changes
_3_mf[0] = "-"
_3_mf[4+2] = "-"


class OneNoun:
    """
    Collect nouns with the same root
    """

    def __init__(self, root_word, root_guess=False):
        self.root_word = root_word
        self.root_guess = root_guess
        self.unique_words = set()
        self.index_to_word = ["-"]*(2*3*4)
        self.index_to_hits = [0]*(2*3*4)

        self.all_word_hits = 0

        # cwp = collision word pair
        self.cwp_to_base_collision_count = {}
        self.cwp_to_morph_collision_count = {}

    def add_word(self, def_art, word, count):
        b_word = g.base_word(word)
        self.all_word_hits += count
        self.unique_words.add(b_word)
        for i in def_art_to_indexes[def_art]:
            self.index_to_hits[i] += count
            if self.index_to_word[i] == "-":
                self.index_to_word[i] = word
            else:
                if self.index_to_word[i] != word:
                    if self.index_to_word[i] > word:
                        key = (self.index_to_word[i], word)
                    else:
                        key = (word, self.index_to_word[i])
                    if b_word == g.base_word(self.index_to_word[i]):
                        self.cwp_to_morph_collision_count[key] = \
                            self.cwp_to_morph_collision_count.get(key, 0) + count
                    else:
                        self.cwp_to_base_collision_count[key] = \
                            self.cwp_to_base_collision_count.get(key, 0) + count

    @staticmethod
    def _idx(sp, ngda, mfn):
        if type(sp) == str:
            sp = "SP".index(sp)
        if type(ngda) == str:
            ngda = "NGDAV".index(ngda)
        if type(mfn) == str:
            mfn = "MFN".index(mfn)
        return (sp*4 + ngda)*3 + mfn

    def derive_roots(self):
        mas_uniq_word_count = len(set((
            g.base_word(word)
            for word in (self.index_to_word[OneNoun._idx(0, i, 0)] for i in range(8))
            if word != "-")))
        mas_case_count = sum((
            1
            for word in (self.index_to_word[OneNoun._idx(0, i, 0)] for i in range(8))
            if word != "-"))
        mas_count = sum((self.index_to_hits[OneNoun._idx(0, i, 0)] for i in [
            0,                      3,
            0 +4,                   3 +4]))

        fem_uniq_word_count = len(set((
            g.base_word(word)
            for word in (self.index_to_word[OneNoun._idx(0, i, 1)] for i in range(8))
            if word != "-")))
        fem_case_count = sum((
            1
            for word in (self.index_to_word[OneNoun._idx(0, i, 1)] for i in range(8))
            if word != "-"))
        fem_count = sum((self.index_to_hits[OneNoun._idx(0, i, 1)] for i in [
            0,      1,      2,      3,
            0 +4,           2 +4,   3 +4]))

        roots = []

        word_f = word_m = decl_m = gen_m = decl_f = gen_f = "-"

        if fem_count > 0 and fem_case_count >= 2:
            count_and_word_list = [
                (wgt(where)*hits, str_rm(word, len(stem)-1), where)
                for hits, word, stem, where in (
                    (self.index_to_hits[i], self.index_to_word[i], stem, where)
                    for i, stem, where in (
                        (OneNoun._idx(sp, ngda, "F"), g._noun_stems["1"]["F"][sp][ngda], sp+ngda)
                        for sp in "SP"
                        for ngda in "NGDA"))
                if where != "SG" and word != "-" and stem[0] == "." and g.base_word(word).endswith(stem[1:])]

            if count_and_word_list:
                count_and_word_list.sort(reverse=True)
                word_f = count_and_word_list[0][1]

#                if count_and_word_list[0][2] in ["PG", "PD"]:
#                    b_word = g.base_word(word_f)
#                    if b_word[-1] == "α":
#                        word_f = word_f[:-1] + "η"
#                    elif b_word[-1] == "η":
#                        word_f = word_f[:-1] + "α"

                if len(word_f) > 2:
                    decl_f, gen_f = g.decl_gen(word_f, "F")
                    roots.append((word_f, "F"))
                    gen = "F"
                else:
                    word_f = "-"

        if mas_count > 0 and mas_case_count >= 2:
            if True:
                print("CHOICES:\n  " + "\n  ".join([
                    repr((stem[0] == "." and g.base_word(word, True).endswith(stem[1:]), wgt(where)*hits, word, stem, where))
                    for hits, word, stem, where in (
                        (self.index_to_hits[i], self.index_to_word[i], stem, where)
                        for i, stem, where in (
                            (OneNoun._idx(sp, ngda, "M"), g._noun_stems["2"]["M"][sp][ngda], sp+ngda)
                            for sp in "SP"
                            for ngda in "NGDA"))
                    if word != "-" ]))
            count_and_word_list = [
                (wgt(where)*hits, str_rm(word, len(stem)-1), where)
                for hits, word, stem, where in (
                    (self.index_to_hits[i], self.index_to_word[i], stem, where)
                    for i, stem, where in (
                        (OneNoun._idx(sp, ngda, "M"), g._noun_stems["2"]["M"][sp][ngda], sp+ngda)
                        for sp in "SP"
                        for ngda in "NGDA"))
                if word != "-" and stem[0] == "." and g.base_word(word, True).endswith(stem[1:])]

            if count_and_word_list:
                count_and_word_list.sort(reverse=True)
                word_m = count_and_word_list[0][1]

                # fix: assume plurals don't change their last letter to α
                if g.base_let(word_m[-1]) == 'α':
                    count_and_word_list = [
                        (wgt(where)*hits, str_rm(word, len(stem)-1), where)
                        for hits, word, stem, where in (
                            (self.index_to_hits[i], self.index_to_word[i], stem, where)
                            for i, stem, where in (
                                (OneNoun._idx("S", ngda, "M"), g._noun_stems["2"]["M"]["S"][ngda], "S"+ngda)
                                for ngda in "NGDA"))
                        if word != "-" and stem[0] == "." and g.base_word(word, True).endswith(stem[1:])]
                    if count_and_word_list:
                        count_and_word_list.sort(reverse=True)
                        word_m = count_and_word_list[0][1]

                if len(word_m) > 2:
                    decl_m, gen_m = g.decl_gen(word_m, "M")
                    roots.append((word_m, "M"))
                    gen = "M"
                else:
                    word_m = "-"

        if False and (decl_m == "3" or decl_f == "3"):
            roots = []

            word = self.index_to_word[1*3]
            if word.endswith("ος"):
                word = self.index_to_word[1*3][:-2]
                roots.append((word, gen))
            else:
                if mas_count > fem_count:
                    gen = "M"
                    gen_i = 0
                else:
                    gen = "F"
                    gen_i = 1

                x1 = list(zip(_3_mf, self.index_to_word[gen_i::3], range(8)))
                x2 = [(w, e) for e, w, i in x1 if e != '-' and g.base_word(w).endswith(e)]
                x3 = [g.base_word(w[:-len(e)]) for w, e in x2]
                count_and_word_list = [
                    (self.index_to_hits[i*3 + gen_i], w[:-len(e)])
                    for e, w, i
                    in zip(_3_mf, self.index_to_word[gen_i::3], range(8))
                    if e != '-' and g.base_word(w).endswith(e)]
                if count_and_word_list:
                    count_and_word_list.sort(reverse=True)
                    word = count_and_word_list[0][1]
                    if len(word) > 2:
                        decl, gen2 = g.decl_gen(word, gen)
                        if decl == "3":
                            roots.append((word, gen))

        return roots

    def show_match(self, _data, idx):
        calc = _data[0]
        _dbg = _data[1]
        found = self.index_to_word[idx]
        hits = self.index_to_hits[idx]

        if found == "-":
            self._dbg_list.append(("-", _dbg))
            return "      " + calc
        elif calc == found:
            self._match += 1
            self._dbg_list.append(("G", _dbg))
            answer = "(-)" + calc
        elif calc == "":
            answer = "(?)" + found
        else:
            if g.base_word(calc) == g.base_word(found):
                self._soft_error += 1
                answer = "(x)" + calc + "->" + found
                self._dbg_list.append(("W", _dbg))
            else:
                self._hard_error += 1
                answer = "(X)" + calc + "->" + found
                self._dbg_list.append(("E", _dbg))
        return "%3d"%hits + answer

    def show_it(self, word, gen1):
        decl, gen2, data = g.noun_inflect_all(word, gen1)[0]

        if not decl in DO_DECLS:
            return False

        print("==================== decl:%s %s:%s %s %s"%(
            decl, gen1, gen2, word, g.base_word(word)))
        print("hits:%d"%(self.all_word_hits))
        if self.root_guess:
            print("ROOT GUESS")

        if self.cwp_to_morph_collision_count:
            print("morph collisions: " + repr(self.cwp_to_morph_collision_count))

        self._dbg_list = []
        self._match = 0
        self._soft_error = 0
        self._hard_error = 0

        max_len = 30
        print("           {1:{0}s} {2:{0}s} {3:{0}s} {4:{0}s}".format(
            max_len+2,
            "__nom__", "__gen__", "__dat__", "__acc__",
            ))
        num_i = 0
        mfn = "MFN".index(gen1)
        for num in ('S', 'P'):
            print("{5}: {1:{0}s} {2:{0}s} {3:{0}s} {4:{0}s}".format(
                max_len+2,
                self.show_match(data[num]["N"], OneNoun._idx(num_i, 0, mfn)),
                self.show_match(data[num]["G"], OneNoun._idx(num_i, 1, mfn)),
                self.show_match(data[num]["D"], OneNoun._idx(num_i, 2, mfn)),
                self.show_match(data[num]["A"], OneNoun._idx(num_i, 3, mfn)),

                num,
                ))
            num_i += 1

        print("----------\nALL REAL: " + ",".join((
            g.base_word(word)
            for word in (
                self.index_to_word[OneNoun._idx(sp, ngad, gen1)]
                for sp in range(2)
                for ngad in range(4))
            if word != "-")))
        if self._dbg_list and _show_errr_dbg:
            print("----------")
            print("\n".join((x[0] + ": " + repr(x[1]) for x in self._dbg_list if x[0] in _show_errr_dbg)))

        return (self._match, self._soft_error)

root_ends = [
    ("1", "M", "ης"),
    ("1", "M", "ας"),
    ("1", "F", "η"),
    ("1", "F", "α"),

    ("2", ".", "ος"),
#    ("2", ".", "αος"),
#    ("2", ".", "εος"),
#    ("2", ".", "ιος"),
#    ("2", ".", "υος"),
#    ("2", ".", "ηος"),
#    ("2", ".", "ωος"),
    ("2", "N", "ον"),
#    ("2", "N", "αον"),
#    ("2", "N", "εον"),
#    ("2", "N", "ιον"),
#    ("2", "N", "υον"),
#    ("2", "N", "ηον"),
#    ("2", "N", "ωον"),

    ("3", ".", "ν"),
    ("3", ".", "ρ"),
    ("3", ".", "ς")]
end_to_what = {}
for decl, gen, end in root_ends:
    gens = gen
    if gens == ".":
        if decl == "3":
            gens = "-"
        else:
            # usualy M, but could be F
            gens = "MF"
    for gen in gens:
        for num in "SP":
            for cas in "NGDA":
                word, _dbg = g._noun_inflect("βββ" + end, decl, gen, num, cas)

                word_end = g.base_word(word[3:])

                what_list = end_to_what.get(word_end, None)
                if not what_list:
                    what_list = []
                    end_to_what[word_end] = what_list
#                print("CP9 %s %s %s %s %s %s"%(word_end, end, decl, gen, num, cas))
                what_list.append((end, decl, num + gen + cas))


_guess_alpha_eta_omicron = True

def derive_root_old(def_art, word, existing_roots=None):
    syllables = g.syllables(word)
    return word[:len(syllables[-1])]

def derive_root(def_art, word, existing_roots=None):
    word = g.base_word(word)
    art_is = set((
        "SP"[(i//12)] + "MFN"[i%3] + "NGDA"[(i//3)%4]
        for i in def_art_to_indexes[def_art]))

    for i in range(4,0,-1):
        word_end = word[-i:]
        what = end_to_what.get(word_end, None)
        if what:
            word_start = word[:-i]
            fildered_what = [   
                (w_end, w_decl)
                for w_end, w_decl, w_ngc in what
                if
                    (
                        w_ngc in art_is
                        or (w_ngc[1] == "-" and (
                            w_ngc[0] + "M" + w_ngc[2] in art_is
                            or w_ngc[0] + "F" + w_ngc[2] in art_is
                            ))
                    ) and (
                        not existing_roots
                        or g.base_word(word_start) + w_end in existing_roots)]
            all_ends = set([end for end, w_decl in fildered_what])
            if len(all_ends) == 1:
                root = word_start + fildered_what[0][0]
                print("CP1 %s %s %s %s %s %s"%(def_art, word, root, repr(art_is), repr(what), repr(all_ends)))
                return root

            if existing_roots:
                # TODO: this section "guesses" the right answer
                # there may be better heuristics here, but is it worth the time?
                if _guess_alpha_eta_omicron:
                    fildered_what = [   
                        (w_end, w_decl)
                        for w_end, w_decl, w_ngc in what
                        if (
                            w_ngc in art_is
                            or (w_ngc[1] == "-" and w_ngc[0] + "M" + w_ngc[2] in art_is))]
                    first_letters = set((end[0] for end, decl in fildered_what))
                    for first_letter in first_letters:
                        if first_letter not in "αηο":
                            break
                    else:
                        last_letters = set((end[1:] for end, decl in fildered_what))
                        if len(last_letters) == 1:
                            # prefere alpha
                            choices = [end for end, decl in fildered_what]
                            choices.sort()

                            root = word_start + choices[0]
                            print("CP1-b %s %s %s %s %s"%(word, root, repr(art_is), repr(what), repr(all_ends)))
                            return root

                    all_ends = set([end for end, w_decl in fildered_what])
                print("CP2 %s %s %s : %s+%s %s | %s"%(def_art, word, g.base_word(word), word_start, word_end, repr(what), repr(art_is)))

    return None

if __name__ == "__main__":

    # create list of OneNoun objects from input files
    art_found = None
    art_word_pairs_to_count = {}
    root_to_OneNoun = {}
    for word in read_words(sys.argv[1:]):
        if g.base_word(word) in def_art_to_indexes:
            art_found = g.base_word(word)
            continue
        if art_found:
            key = (art_found, word)
            art_word_pairs_to_count[key] = art_word_pairs_to_count.get(key, 0)+1
            art_found = None

    second_pass = []
    for def_art_word_pair, count in art_word_pairs_to_count.items():
        def_art, word = def_art_word_pair
        root_word = derive_root(def_art, word)

        if root_word:
            root_word = g.base_word(root_word)
            if not root_word in root_to_OneNoun:
                root_to_OneNoun[root_word] = OneNoun(root_word)
            root_to_OneNoun[root_word].add_word(def_art, word, count)
        else:
            second_pass.append((def_art, word, count))

    for def_art, word, count in second_pass:
        root_word = derive_root(def_art, word, root_to_OneNoun)

        if root_word:
            root_word = g.base_word(root_word)
            if not root_word in root_to_OneNoun:
                root_to_OneNoun[root_word] = OneNoun(root_word, True)
            root_to_OneNoun[root_word].add_word(def_art, word, count)

    show = 0
    not_show = 0
    word_collision = 0
    single_word = 0
    wd_match = 0
    wd_soft_error = 0
    wd_hard_error = 0

    noun_roots_list = list(root_to_OneNoun.values())
#    noun_roots_list.sort(key=lambda r:"%03d%s"%(999-r.all_word_hits, r.root_word))
    noun_roots_list.sort(key=lambda r:g.base_word(r.root_word))

    for noun_root in noun_roots_list:
        if noun_root.cwp_to_base_collision_count:
            word_collision += 1
            print("==================== hits:%d %s"%(noun_root.all_word_hits, repr(noun_root.unique_words)))
            print("word collisions: " + repr(noun_root.cwp_to_base_collision_count))
        elif len(noun_root.unique_words) <= 1:
            print("==================== single:%s %s"%(noun_root.root_word, repr(noun_root.unique_words)))
            single_word += 1
        else:
            # guess masculine and femenine forms of this noun
            words_and_gen = noun_root.derive_roots()
            if not words_and_gen:
                not_show += 1
            else:
                for word, gen1 in words_and_gen:
                    if noun_root.show_it(word, gen1):
                        wd_match += noun_root._match
                        wd_soft_error += noun_root._soft_error
                        wd_hard_error += noun_root._hard_error
                        show += 1
                    else:
                        not_show += 1

    print()
    print()
    print("show %d"%(show))
    print("not show %d"%(not_show))
    print("single %d"%(single_word))
    print("word collision %d"%(word_collision))
    print()
    print("word match %d"%(wd_match))
    print("word soft error %d"%(wd_soft_error))
    print("word hard error %d"%(wd_hard_error))

