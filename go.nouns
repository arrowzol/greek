#!/usr/local/bin/python3

import go_greek as g
import sys

_dbg_show_good_xform = True

def_art_base = (
# singular --------------
#   mas     fem     neu
    "ο",    "η",    "το",       # nominative
    "του",  "της",  "του",      # genative
    "τω",   "τη",   "τω",       # dative
    "τον",  "την",  "το",       # accusative
# plural ----------------
#   mas     fem     neu
    "οι",   "αι",   "τα",       # nominative
    "των",  "των",  "των",      # genative
    "τοις", "ταις", "τοις",     # dative
    "τους", "τας",  "τα")       # accusative

def_art_to_indexes = {}
for def_art, index in zip(def_art_base, range(2*3*4)):
    if not def_art in def_art_to_indexes:
        def_art_to_indexes[def_art] = []
    def_art_to_indexes[def_art].append(index)


def read_words(files, show_ch_vs=False):
    """
    Read greek words from a list of files
    """
    for fn in files:
        fh = open(fn)

        ch = '0'
        for line in fh:
            if line.startswith("CH "):
                ch = line[3:].rstrip()
                continue

            tail = 0;
            in_num = False
            for head in range(len(line)):
                let = line[head]
                if let >= "0" and let <= "9":
                    if not in_num:
                        if head > tail:
                            yield line[tail:head]
                        tail = head
                        in_num = True
                    continue

                if in_num:
                    in_num = False
                    if show_ch_vs:
                        yield ch + ":" + line[tail:head]
                    tail = head

                if not let in g._all_greek_letter_set:
                    if head > tail:
                        yield line[tail:head]
                    if let != " ":
                        yield let
                    tail = head+1
            if tail > head:
                yield line[tail:]
            yield "EOL"
        fh.close()

class NounRoot:
    """
    Collect nouns with the same root
    """

    def __init__(self, root):
        self.root = root
        self.all_hits = 0
        self.unique_words = set()
        self.found = ["-"]*(2*3*4)
        self.hits = [0]*(2*3*4)
        self.word_collisions = {}
        self.morph_collisions = {}

    def add_word(self, def_art, word):
        self.all_hits += 1
        self.unique_words.add(g.base_word(word))
        for i in def_art_to_indexes[def_art]:
            self.hits[i] += 1
            if self.found[i] == "-":
                self.found[i] = word
            else:
                if self.found[i] != word:
                    if self.found[i] > word:
                        key = (self.found[i], word)
                    else:
                        key = (word, self.found[i])
                    if g.base_word(word) == g.base_word(self.found[i]):
                        self.morph_collisions[key] = self.morph_collisions.get(key, 0) + 1
                    else:
                        self.word_collisions[key] = self.word_collisions.get(key, 0) + 1

    def show_match(self, calc, found, _dbg):
        if found == "-":
            return "   " + calc
        if calc == found:
            self._match += 1
            self._good_show.append(_dbg)
            return "(-)" + calc
        if calc == "":
            return "(?)" + found
        self._dbg_show.append(_dbg)
        if g.base_word(calc) == g.base_word(found):
            self._soft_error += 1
            return "(x)" + calc + "->" + found
        else:
            self._hard_error += 1
            return "(X)" + calc + "->" + found

    def derive_roots(self):
        words_m = [
            (self.hits[0*3], self.found[0*3][:-1], "M"),
            (self.hits[2*3], self.found[2*3][:-1], "M"),
            (self.hits[3*3], self.found[3*3][:-1], "M")]
        words_f = [
            (self.hits[0*3+1], self.found[0*3+1], "F"),
            (self.hits[1*3+1], self.found[1*3+1][:-1], "F"),
            (self.hits[3*3+1], self.found[3*3+1][:-1], "F"),
            ]

        words_m.sort(reverse=True)
        words_f.sort(reverse=True)
        
        word_m = words_m[0][1]
        word_f = words_f[0][1]

        # this would be the third declension, no covered yet
        if len(word_m) <= 2 or not g.base_let(word_m[-1]) in "αηο":
            if word_m != "ζῶ":
                word_m = ""
        if len(word_f) <= 2 or not g.base_let(word_f[-1]) in "αηο":
            word_f = ""

        if not word_m and not word_f:
            return ("", "")

        if not word_m:
            word_m = word_f[:-1] + g.cp_morph("ο", word_f[-1])
            word_m = g.translate_morph(word_m, len(word_m)-1, "\\", "/") or word_m
        elif not word_f:
            word_f = word_m[:-1] + g.cp_morph("α", word_m[-1])

        count_m = sum((self.hits[i*3] for i in range(8)))
        if not count_m:
            word_m = ""
        count_f = sum((self.hits[i*3+1] for i in range(8)))
        if not count_f or count_f * 20 < count_m:
            word_f = ""

        return (word_m, word_f)

    def show_it(self):
        word_f = None
        word_m = None

        if self.word_collisions:
            print("==================== hits:%d M:%s F:%s"%(self.all_hits, word_m, word_f))
            print("word collisions: " + repr(self.word_collisions))
            return

        # guess masculine and femenine forms of this noun
        if self.found[1] == "secret":
            pass
        else:
            word_m, word_f = self.derive_roots()

        if word_m:
            data_m = g.noun_inflect_all(word_m, "M")
            data_f = g.noun_inflect_all(word_f, "F")
            data_n = g.noun_inflect_all(word_m, "N")

            print("==================== hits:%d M:%s F:%s"%(self.all_hits, word_m, word_f))

            if self.morph_collisions:
                print("morph collisions: " + repr(self.morph_collisions))

            self._dbg_show = []
            self._good_show = []
            self._match = 0
            self._soft_error = 0
            self._hard_error = 0
            for i in range(8):
                print("    {3:3d}{0:30s}{4:3d}{1:30s}{5:3d}{2:30s}".format(
                    self.show_match(data_m[i][1], self.found[i*3]  , data_m[i][2]),
                    self.show_match(data_f[i][1], self.found[i*3+1], data_f[i][2]),
                    self.show_match(data_n[i][1], self.found[i*3+2], data_n[i][2]),
                    self.hits[i*3],
                    self.hits[i*3+1],
                    self.hits[i*3+2],
                    ))
            if self._dbg_show:
                print("bad:" + "\nbad:".join((repr(x) for x in self._dbg_show)))
            if _dbg_show_good_xform:
                if self._good_show:
                    print("good:" + "\ngood:".join((repr(x) for x in self._good_show)))
            return (self._match, self._soft_error)


if __name__ == "__main__":

    # create list of NounRoot objects from input files
    art_found = None
    noun_roots = {}
    for word in read_words(sys.argv[1:]):
        if g.base_word(word) in def_art_to_indexes:
            art_found = word
            continue
        if art_found:
            def_art = g.base_word(art_found)
            art_found = None

            root, last_syllable = g.split_last_syllable(word)

            if root:
                root = g.base_word(root)
                if not root in noun_roots:
                    noun_roots[root] = NounRoot(root)
                noun_roots[root].add_word(def_art, word)

    show = 0
    not_show = 0
    word_collision = 0
    single_word = 0
    wd_match = 0
    wd_soft_error = 0
    wd_hard_error = 0

    noun_roots_list = list(noun_roots.values())
    noun_roots_list.sort(key=lambda r:"%03d%s"%(999-r.all_hits, r.root))

    for noun_root in noun_roots_list:
        if noun_root.word_collisions:
            word_collision += 1
            noun_root.show_it()
        elif len(noun_root.unique_words) <= 1:
            single_word += 1
        else:
            if noun_root.show_it():
                wd_match += noun_root._match
                wd_soft_error += noun_root._soft_error
                wd_hard_error += noun_root._hard_error
                show += 1
            else:
                not_show += 1

    print()
    print()
    print("show %d"%(show))
    print("not show %d"%(not_show))
    print("single %d"%(single_word))
    print("word collision %d"%(word_collision))
    print()
    print("word match %d"%(wd_match))
    print("word soft error %d"%(wd_soft_error))
    print("word hard error %d"%(wd_hard_error))

