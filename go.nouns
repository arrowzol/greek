#!/usr/local/bin/python3

import greek_letter as gl
import greek_noun as gn
import greek_dict as gd
import sys

DO_DECLS = "12"
DO_DECLS = "3"
DO_DECLS = "123"

_show_errr_dbg = "-GEW"

def wgt(where):
    if where == "SN":
        return 10
    return 1

def str_rm(s, i):
    if i == 0:
        return s
    return s[:-i]

def read_words(files, show_ch_vs=False):
    """
    Read greek words from a list of files
    """
    for fn in files:
        fh = open(fn)

        ch = '0'
        for line in fh:
            if line.startswith("CH "):
                ch = line[3:].rstrip()
                continue

            tail = 0;
            in_num = False
            for head in range(len(line)):
                let = line[head]
                if let >= "0" and let <= "9":
                    if not in_num:
                        if head > tail:
                            yield line[tail:head]
                        tail = head
                        in_num = True
                    continue

                if in_num:
                    in_num = False
                    if show_ch_vs:
                        yield ch + ":" + line[tail:head]
                    tail = head

                if not let in gl._all_greek_letter_set:
                    if head > tail:
                        yield line[tail:head]
                    if let not in " \t\n\r":
                        yield let
                    tail = head+1
            if tail+1 < len(line):
                yield line[tail:]
            yield "EOL"
        fh.close()

_3_mf = [gn._noun_stems["3"]["-"][num][case]
    for num in "SP"
    for case in "NGDA"
    ]

# look out for NS and DP, their endings start with a consonant and many changes
_3_mf[0] = "-"
_3_mf[4+2] = "-"


class OneNoun:
    """
    Collect nouns with the same root
    """

    def __init__(self, root_word, root_guess=False):
        self.root_word = root_word
        self.dgnc = set()
        self.root_guess = root_guess
        self.unique_words = set()
        self.index_to_word = ["-"]*(2*3*4)
        self.index_to_hits = [0]*(2*3*4)

        self.all_word_hits = 0

        # cwp = collision word pair
        self.cwp_to_base_collision_count = {}
        self.cwp_to_morph_collision_count = {}

    def add_word(self, word, dgnc, count):
        i = OneNoun._idx2(dgnc)
        b_word = gl.base_word(word)
        self.all_word_hits += count
        self.unique_words.add(b_word)

        self.index_to_hits[i] += count
        if self.index_to_word[i] == "-":
            self.index_to_word[i] = word
        else:
            if self.index_to_word[i] != word:
                if self.index_to_word[i] > word:
                    key = (i, self.index_to_word[i], word)
                else:
                    key = (i, word, self.index_to_word[i])
                if b_word == gl.base_word(self.index_to_word[i]):
                    self.cwp_to_morph_collision_count[key] = \
                        self.cwp_to_morph_collision_count.get(key, 0) + count
                else:
                    self.cwp_to_base_collision_count[key] = \
                        self.cwp_to_base_collision_count.get(key, 0) + count

    @staticmethod
    def _idx(sp, ngda, mfn):
        if type(sp) == str:
            sp = "SPN".index(sp)
        if type(ngda) == str:
            ngda = "NGDAV".index(ngda)
        if type(mfn) == str:
            mfn = "MFN".index(mfn)
        return (sp*4 + ngda)*3 + mfn

    @staticmethod
    def _idx2(dgnc):
        return OneNoun._idx(dgnc[2], dgnc[3], dgnc[1])

    def derive_roots(self):
        roots = []

        mas_case_count = sum((
            1
            for word in (self.index_to_word[OneNoun._idx(0, i, 0)] for i in range(8))
            if word != "-"))
        mas_count = sum((self.index_to_hits[OneNoun._idx(0, i, 0)] for i in [
            0,                      3,
            0 +4,                   3 +4]))
        if mas_count > 0 and mas_case_count >= 2:
            roots.append((self.root_word, "M"))

        fem_case_count = sum((
            1
            for word in (self.index_to_word[OneNoun._idx(0, i, 1)] for i in range(8))
            if word != "-"))
        fem_count = sum((self.index_to_hits[OneNoun._idx(0, i, 1)] for i in [
            0,      1,      2,      3,
            0 +4,           2 +4,   3 +4]))
        if fem_count > 0 and fem_case_count >= 2:
            roots.append((self.root_word, "F"))

        neu_case_count = sum((
            1
            for word in (self.index_to_word[OneNoun._idx(0, i, 2)] for i in range(8))
            if word != "-"))
        neu_count = sum((self.index_to_hits[OneNoun._idx(0, i, 2)] for i in [
            0,                      3,
            0 +4,                   3 +4]))
        if neu_count > 0 and neu_case_count >= 2:
            roots.append((self.root_word, "N"))

        return roots

    def show_match(self, _data, idx):
        calc = _data[0]
        _dbg = _data[1]
        found = self.index_to_word[idx]
        hits = self.index_to_hits[idx]

        if found == "-":
            self._dbg_list.append(("-", _dbg))
            return "      " + calc
        elif calc == found:
            self._match += 1
            self._dbg_list.append(("G", _dbg))
            answer = "(-)" + calc
        elif calc == "":
            answer = "(?)" + found
        else:
            if gl.base_word(calc) == gl.base_word(found):
                self._soft_error += 1
                answer = "(x)" + calc + "->" + found
                self._dbg_list.append(("W", _dbg))
            else:
                self._hard_error += 1
                answer = "(X)" + calc + "->" + found
                self._dbg_list.append(("E", _dbg))
        return "%3d"%hits + answer

    def show_it(self, word, gen1):
        decl, gen2, data = gn.noun_inflect_all(word, gen1)[0]

        if not decl in DO_DECLS:
            return False

        print("==================== decl:%s %s:%s %s %s"%(
            decl, gen1, gen2, word, gl.base_word(word)))
        print("hits:%d"%(self.all_word_hits))
        if self.root_guess:
            print("ROOT GUESS")

        if self.cwp_to_morph_collision_count:
            print("morph collisions: " + repr(self.cwp_to_morph_collision_count))

        self._dbg_list = []
        self._match = 0
        self._soft_error = 0
        self._hard_error = 0

        max_len = 30
        print("           {1:{0}s} {2:{0}s} {3:{0}s} {4:{0}s}".format(
            max_len+2,
            "__nom__", "__gen__", "__dat__", "__acc__",
            ))
        num_i = 0
        mfn = "MFN".index(gen1)
        for num in ('S', 'P'):
            print("{5}: {1:{0}s} {2:{0}s} {3:{0}s} {4:{0}s}".format(
                max_len+2,
                self.show_match(data[num]["N"], OneNoun._idx(num_i, 0, mfn)),
                self.show_match(data[num]["G"], OneNoun._idx(num_i, 1, mfn)),
                self.show_match(data[num]["D"], OneNoun._idx(num_i, 2, mfn)),
                self.show_match(data[num]["A"], OneNoun._idx(num_i, 3, mfn)),

                num,
                ))
            num_i += 1

        print("----------\nALL REAL: " + ",".join((
            gl.base_word(word)
            for word in (
                self.index_to_word[OneNoun._idx(sp, ngad, gen1)]
                for sp in range(2)
                for ngad in range(4))
            if word != "-")))
        if self._dbg_list and _show_errr_dbg:
            print("----------")
            print("\n".join((x[0] + ": " + repr(x[1]) for x in self._dbg_list if x[0] in _show_errr_dbg)))

        return (self._match, self._soft_error)

def derive_root(article, word, existing_roots=None):
    GNC_set = gn.gnc_set_from_article(article)
    return gn.derive_root_given_GNC(GNC_set, word, existing_roots)

if __name__ == "__main__":

    gn._dbg_on = True
    # create list of OneNoun objects from input files
    article_found = None
    article_word_to_count = {}
    root_to_OneNoun = {}
    b_word_set = set()
    in_dict_count = 0
    not_in_dict_count = 0
    for word in read_words(sys.argv[1:]):
        b_word = gl.base_word(word)
        if b_word in gn.article_to_indexes:
            article_found = b_word
            continue
        if article_found:
            if gl.all_greek_letter(word):
                if b_word not in b_word_set:
                    b_word_set.add(b_word)
                    key = (article_found, word)
                    article_word_to_count[key] = article_word_to_count.get(key, 0)+1
            article_found = None

    second_pass = []
    for article_word, count in article_word_to_count.items():
        article, word = article_word
        dw = gd.lookup(word)
        if dw:
            print("CP5d1: dict found %s %s"%(word, gl.base_word(word)))
            in_dict_count += 1
        else:
            print("CP5d0: dict not found %s %s"%(word, gl.base_word(word)))
            not_in_dict_count += 1

        GNC_set = gn.gnc_set_from_article(article)
        root_word, dgnc = gn.derive_root_given_GNC(GNC_set, word)

        if root_word:
            print("CP5r1: %s %s"%(root_word, dgnc))
            b_root_word = gl.base_word(root_word)
            if b_root_word not in root_to_OneNoun:
                root_to_OneNoun[b_root_word] = OneNoun(root_word)
            root_to_OneNoun[b_root_word].add_word(word, dgnc, count)
        else:
            # for display only
            GNC_list = list(GNC_set)
            GNC_list.sort()
            print("CP5r0: %s %s"%(repr(GNC_list), word))
            second_pass.append((article, word, count))

    for article, word, count in second_pass:
        root_word, dgnc = derive_root(article, word, root_to_OneNoun)

        if root_word:
            root_word = gl.base_word(root_word)
            if not root_word in root_to_OneNoun:
                root_to_OneNoun[root_word] = OneNoun(root_word, True)
            root_to_OneNoun[root_word].add_word(word, dgnc, count)

    show = 0
    not_show = 0
    word_collision = 0
    single_word = 0
    wd_match = 0
    wd_soft_error = 0
    wd_hard_error = 0

    noun_roots_list = list(root_to_OneNoun.values())
#    noun_roots_list.sort(key=lambda r:"%03d%s"%(999-r.all_word_hits, r.root_word))
    noun_roots_list.sort(key=lambda r:gl.base_word(r.root_word))

    for noun_root in noun_roots_list:
        if noun_root.cwp_to_base_collision_count:
            word_collision += 1
            print("==================== hits:%d %s"%(noun_root.all_word_hits, repr(noun_root.unique_words)))
            print("word collisions: " + repr(noun_root.cwp_to_base_collision_count))
        elif len(noun_root.unique_words) <= 1:
            print("==================== single:%s %s"%(noun_root.root_word, repr(noun_root.unique_words)))
            single_word += 1
        else:
            # guess masculine and femenine forms of this noun
            listof_word_gen = noun_root.derive_roots()
            if not listof_word_gen:
                not_show += 1
            else:
                for word, gen1 in listof_word_gen:
                    if noun_root.show_it(word, gen1):
                        wd_match += noun_root._match
                        wd_soft_error += noun_root._soft_error
                        wd_hard_error += noun_root._hard_error
                        show += 1
                    else:
                        not_show += 1

    print()
    print()
    print("show %d"%(show))
    print("not show %d"%(not_show))
    print("single %d"%(single_word))
    print("word collision %d"%(word_collision))
    print()
    print("word match %d"%(wd_match))
    print("word soft error %d"%(wd_soft_error))
    print("word hard error %d"%(wd_hard_error))
    print();
    print("in_dict_count = %d"%(in_dict_count))
    print("not_in_dict_count = %d"%(not_in_dict_count))

